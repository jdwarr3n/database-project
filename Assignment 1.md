## COMP 530 Assignment 1: LRU Buffer Manager

### 1\. The Task

In Assignment 1, your task is to build a LRU buffer manager. This buffer manager is responsible for managing a pool of pages that are going to be used to buffer temporary data, and that will be used to buffer pages from database tables. This buffer manager will serve as the foundation that the rest of our database system (called "MyDB").

In the archive A1-4.zip, I've provided for you a skeleton of the project. You are required to use this skeleton-we'll be adding to this code base and extending it over the semester, so everyone has to be on the same page (no pun intended\!). In particular, for A1, you'll be extending the code in the files MyDB\_BufferManager.h, MyDB\_PageHandle.h, MyDB\_BufferManager.cc, and MyDB\_PageHandle.cc. Currently, the latter two files are just placeholders so that things compile. The former two contain the interface that you are required to implement, though you can add additional member functions and data members as needed. It's also likely the case that you'll be adding new helper classes that will help you to perform the various buffer management tasks.

### 2\. Details, Details, Details

**2.1 Types of Pages** There are two types of pages managed by this LRU buffer manager; pages that are associated with some position in an actual file/database table, and pages that are anonymous and are used as temporary storage by the rest of your system. Your buffer manager will have to write both kinds of pages back to disk to free memory when the buffer runs out of free pages. The difference between the two page types is that pages mapped to an actual file are written exactly to the file and position that they are mapped to, but anonymous pages are just stored somewhere on disk; the user of the buffer manager does not care where. In your implementation, all anonymous pages should be mapped to slots in a single temporary file.

**2.2 Pinning Pages** Note that with the interface we've defined, it is possible to pin pages. A pinned page is always kept in RAM; it is never written back to disk. Thus, allocating a pinned page essentially takes a page out of the buffer pool, and the page's memory is not available to other pages until the user is done with the pinned page. Thus, the number of pinned pages cannot exceed the size of the buffer pool, since the pool can't have less than zero available memory.

**2.3 Pages versus Page Handles** As you'll see when you look over the code skeleton, the buffer manager's interface returns handles to pages, and not pages themselves. The pages themselves remain under the control of the buffer manager and are not accessible to users of the buffer manager; the pages are accessed by the rest of the system via the handles. When a user requests the same page multiple times, the page is only added to the pool one time. However, multiple handles to the page are created, one for each request.

When all of the handles to an anonymous page are gone, then it is impossible for the anonymous page to ever be accessed again, and the page's memory is automatically returned to the pool of unused memory, pinned or not. Since the page can never be accessed, the disk slot associated with the anonymous page should be recycled, so that subsequent anonymous pages can use that slot.

When all of the handles to a pinned, non-anonymous page are gone, then the page should be automatically unpinned. Later requests for that page may create new handles for the page, but at the point that the page has no more handles to it. Thus, it becomes possible for the page to be evicted from the buffer pool and its memory assigned to another page. Of course, the page can be re-pinned if, in the future, a handle to the same page is requested, but it is specified that the page should be pinned.

Since handles are implemented via C++ smart pointers, the destructor for the handle's class is automatically called when it is impossible to reach the handle (when the handle does not remain in any containers, and it has gone out of scope). At that point, you can reduce the reference count for the page.

**2.4 Memory Allocation and File I/O** I'll ask you to allocate all of the buffer manager's memory all at once, in the constructor for the buffer manager. Memory for pages should not be allocated on-the-fly. You can either use malloc or mmap to do the allocation. Flle I/O should be done using the open, read, write, and 1seek libc functions. Make sure to use the O\_FSYNC option when opening the file, so that writes are not buffered by the operating system.

**2.5 Testing And Grading** In this class, we're using a very simple little test harness for C++ called Qunit. I have written one very extensive Qunit test for the buffer manager, and included it in the skeleton. It is located in BufferTest/source/BufferQUnit.cc. When you build your project using the SCons build tool (see below), this file will be complied and an executable will be produced. If you can make it through my one big test case, it is likely that you've worked through the majority of the bugs in your buffer manager, and you've got most of the functionality done. However, you'll probably want to create a few additional test cases of your own- some simpler ones that you can use early on as you develop your code, and some additional, nasty ones just to make sure that everything is working.

When you turn in your code, and it's time for us to grade, we'll run the one big test case I've suppled, as well as several others that won't be made public until after the turnin. You'll be graded on your code's success in passing all of the test cases, though we revere the right to browse through your code and take off additional points if it appears you are missing some functionality or have somehow hacked something in a sketchy sort of way. You won't be graded on style and comments. However, I strongly encourage you to take this opportunity to put your best software engineering practices to use.

**2.6 Project Difficulty** To let you know about how much code you'll write, here's the size of my own solution: \[cmj4@ring Main\]$ wc \-l BufferMgr/\*/\*.cc BufferMgr/\*/\*.h 273 BufferMgr/source/MyDB\_BufferManager.cc 40 BufferMgr/source/MyDB\_Page.cc 17 BufferMgr/headers/CheckLRU.h 97 BufferMgr/headers/MyDB\_BufferManager.h 79 BufferMgr/headers/MyDB\_Page.h 57 BufferMgr/headers/MyDB\_PageHandle.h 27 BufferMgr/headers/PageCompare.h 27 BufferMgr/headers/TableCompare.h 617 total 617 lines. That includes a lot of comments. Not huge, but not tiny. I'd anticipate that most teams are going to put in around 10 hours per person (teams of two) to get this assignment completed.

